# -*- coding: utf-8 -*-
"""Homework_03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SYuUjfl1IM_vRb1bSpat3mdDAcmmNM0z

# Convolution Neural Network Homework

This is the 3rd assignment for CAP 4630 and we will go through some primary operations for image processsing and implement one of the earilest representative convolution neural network - LeNet-5 . \
You will use **"Tasks"** and **"Hints"** to finish the work. **(Total 100 Points)** \
For section 1, when you implement covolution and maxpooling, you are **not** allowed to use built-in functions in Machine Learning libaries such as Scikit-learn Keras, Tensorflow, Pytorch; but you are encouraged to employ Keras for second section.

**Task Overview:**
- Basic operations for Digital Image Processing (DIP)
- LeNet-5 (Google Colab is recommended for implementation)

## 1 - Basic Image Processing ##
### 1.1 Data Preparation 

Import useful packages and prepare image data as an array for image processing. **(5 Points)**

**Tasks:**
1. Import numpy and rename it to np.
2. Import imageio and call imread to convert image to an array.
3. **DISPLAY** the image in the output box before image-array conversion.
4. **PRINT OUT** the size of the array
5. **PRINT OUT** the numeric matrix form of image, i.e. the obtained array after image-array conversion.

References:
- [numpy](www.numpy.org) is the fundamental package for scientific computing with Python.
- [imageio](https://imageio.github.io/) is a python library for basic image reading and writing.

**Hints:**
1. Image data is under current directory, i.e., "./image.jpg".
2. You may consider importing "display" and "Image" from IPython.display for image display.
"""

# Import useful libraries
import numpy as np
import imageio
from IPython.display import display, Image

# Display original image
display(Image(filename='image.jpg'))

# # Convert image to array, print out the shape of array, and print out the entire array
img_matrix = np.array(imageio.imread('image.jpg'))
print('\nSize of array =', img_matrix.shape, '\n')
print(img_matrix)

"""### 1.2 Implementation of Convolution Filter

Process the obtained array from the image with convolution operation. **(20 Points)**

**Tasks:**
1. Prepare a 3X3 Laplacian kernel (aka Laplacial filter) with array as convolution filter.
2. Conduct convolution on image with prepared kernel.
3. **PRINT OUT** convolution result for first ten rows.
4. **PRINT OUT** the shape of the convolution result.
5. **DISPLAY** convolution result as image with matplotlib. (Don't worry about the value <0 or >255. Scaling process will be conducted in imshow function to make sure valid display.)


**Hints:**
1. Laplacian kernel is widely used for edge detection. Its form is shown below:


![](https://drive.google.com/uc?export=view&id=15bP8KCwHLtglJ-WXV4wolm4m46mCp3HL)

2. You may consider the following steps for this implementation.\
    2.1 Extract all centriods of processing region for each convolution operation.\
    2.2 According to each centroid, locate all indices of the elements within the local region for each convolution operation.\
    2.3 Given obtained indices, locate pixel values (i.e. our obtained array elements) and conduct element-wise product between pixel and kernel values.\
    2.4 Sum element-wise product results and assign the value to convolution result at corresponding location.\
    **Note: we did not conduct padding for processed array, and thus, convolution result will become smaller than original array. You may think about the reason.**
3. Validation for first 5X5 array (from upper-left corner), i.e., filtered_results[0:5,0:5]. The example figure is below.

[[ 134.   37.   98.  195.  173.]\
 [ -75.  -80.   56.  -65.  182.]\
 [  96.  -37. -163.   22.   68.]\
 [-101.  121.   81.  148.  -71.]\
 [   7.  127. -141.  159. -127.]]

![](https://drive.google.com/uc?export=view&id=18Iis1mJsvEaojZ7O3f3soE152Szwy8_Z)


 
"""

######## Convolution with Laplacian Filter ##################
import matplotlib.pyplot as plt


l_kernel = np.array([[0,1,0],[1,-4,1],[0,1,0]])
kernel_center_x , kernel_center_y = len(l_kernel) // 2, len(l_kernel) // 2
convolved_matrix = []

img_size = img_matrix.shape[0]

kernel_size = 3


idx = 0

# Loop over each pixel in the image and kernel
# -2 for i and j since the kernel will already loop through those
for i in range(0, img_size - 2):
    for j in range(0, img_size - 2):
        convolved_matrix.append(0)
        for x in range(kernel_size):
            for y in range(kernel_size):
                if x + i < 30 and y + j < 30:
                    convolved_matrix[idx] += float(l_kernel[x][y] * img_matrix[(x+ i)][(y + j)])
        idx += 1

convolved_matrix = np.array(convolved_matrix) 
sqrt = int(len(convolved_matrix)**0.5)
convolved_matrix = np.reshape(convolved_matrix, (sqrt, sqrt))

print('First 10 rows:')
print(convolved_matrix[0:10, :],'\n')

print('Shape:', convolved_matrix.shape)

convolved_image = plt.imshow(convolved_matrix)

"""### 1.3 Modification on Convolution Scheme

Conduct the convolution with the same filter as above, but change the stride to 2. **(5 Points)**

**Tasks:**
1. Modify the convolution process with stride=2
2. **PRINT OUT** convolution result for first ten rows.
3. **PRINT OUT** the shape of the convolution result.
4. **DISPLAY** convolution result as image with matplotlib.(Don't worry about the value <0 or >255. Scaling process will be conducted in imshow function to make sure valid display.)

**Hints:**
1. You may just reduce the centroid pool according to stride=2, and then, follow the same convolution process above.
    **Note: After increase of stride, the size of convolution result is further shrinked. You may think about the reason.**
2. Validation for first 5X5 array (from upper-left corner), i.e., filtered_results[0:5,0:5]. The example figure is below.

[[ 134.   98.  173.    5.    3.]\
 [  96. -163.   68.  -10.   37.]\
 [   7. -141. -127.  142.   -6.]\
 [  -1.  -46.  109.  -13.   11.]\
 [ 106.   49.  241.  -26.  -33.]]
 
 
![](https://drive.google.com/uc?export=view&id=1UPdXt5cY1umImu2chaQLfWAnqDEpFOGV)

"""

######## Convolution with Laplacian Filter and the setting of stride=2 ##################
l_kernel = np.array([[0,1,0],[1,-4,1],[0,1,0]])
kernel_center_x , kernel_center_y = len(l_kernel) // 2, len(l_kernel) // 2
convolved_matrix = []

img_size = img_matrix.shape[0]

kernel_size = 3


idx = 0

# Loop over each pixel, skipping 2, in the image and kernel
# -2 for i and j since the kernel will already loop through those
for i in range(0, img_size - 2, 2):
    for j in range(0, img_size - 2, 2):
        convolved_matrix.append(0)
        for x in range(kernel_size):
            for y in range(kernel_size):
                if x + i < 30 and y + j < 30:
                    convolved_matrix[idx] += float(l_kernel[x][y] * img_matrix[(x+ i)][(y + j)])
        idx += 1

convolved_matrix = np.array(convolved_matrix) 
sqrt = int(len(convolved_matrix)**0.5)
convolved_matrix = np.reshape(convolved_matrix, (sqrt, sqrt))

print('First 10 rows:')
print(convolved_matrix[0:10, :],'\n')

print('Shape:', convolved_matrix.shape)

convolved_image = plt.imshow(convolved_matrix)

"""### 1.4 Implementation of MaxPooling

Process the obtained array from the image with MaxPooling operation. **(15 Points)**

**Tasks:**
1. Prepare a 2X2 pooling mask.
2. Conduct max pooing on image with prepared mask.
3. **PRINT OUT** convolution result for first ten rows.
4. **PRINT OUT** the shape of the convolution result.
5. **DISPLAY** convolution result as image with matplotlib.(Don't worry about the value <0 or >255. Scaling process will be conducted in imshow function to make sure valid display.)

**Hints:**
1. You may just modify the centroid pool to top-left corner pool, and then, follow the same strategy above.\
    **Note: After the pooling, the size of the array is shrinked. You may think about the reason.**
2. Validation for first 5X5 array (from upper-left corner), i.e., pooled_results[0:5,0:5].The example figure is below.

[[ 98. 112.  93. 195. 173.]\
 [ 84. 127. 137. 253. 254.]\
 [ 85. 145. 225. 255. 242.]\
 [104. 178. 216. 230. 242.]\
 [ 95. 186. 147. 248. 242.]]

![](https://drive.google.com/uc?export=view&id=1a18IWjrN0xHcp7bSNuj8kUM4JFFj3ebd)


"""

######## MaxPooling with the setting of 2X2 ##################

l_kernel = np.array([[0,1,0],[1,-4,1],[0,1,0]])
pooling_matrix = []
img_size = img_matrix.shape[0]

def pooling_mask(img_matrix, i, j):
    mask = max(img_matrix[i][j], img_matrix[i+1][j+1], \
                                 img_matrix[i+1][j], img_matrix[i][j+1])
    return mask


idx = 0

# Loop over each square of 4 pixels in the image and use max pooling to create a new matrix
for i in range(0, img_size, 2):
    for j in range(0, img_size, 2):
        pooling_matrix.append(pooling_mask(img_matrix, i, j))
        

pooling_matrix = np.array(pooling_matrix) 
sqrt = int(len(pooling_matrix)**0.5)
pooling_matrix = np.reshape(pooling_matrix, (sqrt, sqrt))

print('First 10 rows:')
print(pooling_matrix[0:10, :],'\n')

print('Shape:', pooling_matrix.shape)

pooling_image = plt.imshow(pooling_matrix)

"""## 2 - Convolution Neural Network ##
 
In this section, we will use LeNet-5 (LeCun et al., 1998), one of representative deep nueral networks, to solve a  classification problem with Fashion MNIST benchmark.

### 2.1 Library Preparation

Import useful deep learning packages. 

**Tasks:**
1. Import numpy and rename it to np.
2. Import keras from tensorflow.
3. Import layers from tensorflow.keras

"""

import numpy as np
import keras
from keras import layers

"""### 2.2 Training Data Preparation

Import useful packages and prepare Fashion MNIST data. **(20 Points)**

**Tasks:**
1. Download Fashion MNIST data and split it with keras and prepare training/test data sets.
2. Preprocess training/test data with normalization, dimension extension, and zero padding (for LeNet-5 configuration).
3. Preprocess label data to binary class matrices.
4. **PRINT OUT** first image in training set and its correponding label index
5. **PRINT OUT** the shape of total training data, the number of training samples, and the number of test samples.

**Hints**
1. You may consider load function from the reference link. https://keras.io/api/datasets/ It provides dataloader function which can tackle downloading and data splitting automatically.
2. For label preprocessing, you may consider **keras.utils.to_categorical** to convert class vectors to binary class matrices. This conversion makes sure the label can match the format of prediction output from neural network.
3. For image display, consider showing the image and label **before dimension expansion and label preprocessing**.
4. You may consider MNIST processing shown in class as an example.

**References**
- Fashion MNIST https://github.com/zalandoresearch/fashion-mnist

"""

# # the data, split between train and test sets with keras.datasets
f = keras.datasets.fashion_mnist.load_data()
(x_train, y_train), (x_test, y_test) = f
#print(f)

# Model / data parameters
num_classes = 10
input_shape = (32, 32, 1) ## think about the reason

# # Image Normalization (Scaling to [0, 1])
x_train = x_train / 255.0
x_test = x_test / 255.0

# Print out first image and its correponding label index
plt.figure()
plt.imshow(x_train[0])
plt.show()
print('\nlabel index = ', y_train[0])
    
# # Dimension expansion to ensure that images have shape (28, 28, 1)
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

# # Conduct padding on training/test images to (32, 32, 1) for LeNet-5
x_train = np.pad(x_train, ((0,0),(2,2),(2,2),(0,0)), 'constant')
x_test = np.pad(x_test, ((0,0),(2,2),(2,2),(0,0)), 'constant')

# # Print out the training/test data shapes and the numbers of training/test samples
print("x_train shape:", x_train.shape)
print(x_train.shape[0], "train samples")
print(x_test.shape[0], "test samples")

# # convert label vectors to binary class matrices for training/test labels 
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

"""### 2.3 LeNet-5 

Construct LeNet-5 as learning model for Fashion MNIST classification task. **(15 Points)**

**Tasks:**
1. Build up LeNet-5 with keras.Sequential
2. Set the regularizer to l2 and regularizer lambda is **4e-5**.
2. **PRINT OUT** the model summary.

**Hints:**
1. You may consider the convolution neural network shown in class as an example.
2. The structure of LeNet-5 is listed below. Try to map each step to related processing operation. You can also search some materials to faciliate implementation. 
3. Some architecture settings are listed below. 
    - The kernel size for 2D convolution filter is **5 X 5**. You may think about the reason by calculation.
    - Regularizer is set to L2 regularizer with **kernel_regularizer=regularizers.l2(4e-5)**.
    - We change tanh activation to **"relu"** activation here. Please use **activation="relu"** for implementation.
    - We use MaxPooling instead of original AveragePooling. Please use "**MaxPooling2D(pool_size=(2, 2))**" for implementation.
    - Please use **Flatten** to onvert 2D convolution layer to 1D fully connected layer.
    - Gaussian connections are replaced with Softmax, and thus, the outputs are activated by Softmax function based on the number of classes.

4. Validation result:
    - Total params: 61,706
    - Trainable params: 61,706
    - Non-trainable params: 0

![](https://drive.google.com/uc?export=view&id=1Ks9RasENa0KiYRi2vwfJ_BQxkLB-x49R)


**References:**
- http://yann.lecun.com/exdb/lenet/

"""

### Construct LeNet-5

from keras import regularizers
keras.backend.clear_session()
lamda = regularizers.l2(4e-5)

model = keras.Sequential(
    [
        keras.Input(shape=input_shape),
        layers.Conv2D(filters=6, kernel_size=(5,5), kernel_regularizer=regularizers.l2(4e-5), activation='relu'), #C1
          layers.MaxPooling2D(pool_size=(2,2)), # S2 Subsampling
          layers.Conv2D(filters=16, kernel_size=(5,5), kernel_regularizer=regularizers.l2(4e-5), activation='relu'), # C3
          layers.MaxPooling2D(pool_size=(2,2)), # S4 Subsampling
          layers.Flatten(), # Convert 2D convolution layer to 1D fully connected layer
          layers.Dense(units=120, kernel_regularizer=regularizers.l2(4e-5), activation ='relu'), # C5
          layers.Dense(units=84, kernel_regularizer=regularizers.l2(4e-5), activation = 'relu'), # F6
          layers.Dense(num_classes, activation='softmax'), # OUTPUT
    ]
)

model.summary()

"""#### 2.4 LeNet-5 Model Training

Train LeNet-5 model with specific training strategy. **(20 Points)**

**Tasks:**
1. Set batch size to **64** for training. 
2. Pick **SGD optimizer** with learning rate of **0.1**, momentum of **0.9**, and **nesterov=True**, for model training.
3. Pick **cross-entropy** loss function for optimization and evaluation metrics is set to **accuracy**.
4. Set validation_split to **0.1** which means it excludes 1/10 training data for validation process.
4. Train the model with **10 epochs**.
5. Evaluate model with test data set and **PRINT OUT** : **test loss** and **test accuracy**. Note that the model here is the **LAST** model after **10 epochs** training.

**Hints:**
1. You may consider the examples from Keras to specify optimizer parameters. https://keras.io/api/optimizers/
2. You may use the example shown in class to faciliate this implementation.
3. You may see slightly different results every time you run the training. It is normal since there is randomness for training. However, you should expect the **BEST** validation accuracy is above **87%** which may not be the result from last epoch.
"""

### Train with SGD optimizer with learning rate =0.1, regularizer=4e-5, momentum=0.9, and nesterov=True

batch_size = 64
epochs = 10
sgd = keras.optimizers.SGD(learning_rate=0.1, momentum=0.9, nesterov=True)
model.compile(loss=keras.losses.categorical_crossentropy, optimizer=sgd, metrics=['accuracy'])
history = model.fit(x=x_train, y=y_train, batch_size=batch_size, epochs=epochs, validation_split=0.1)

### Print out the evaluation results, including test loss and test accuracy.

score = model.evaluate(x=x_test, y=y_test, verbose=0)
print("Test loss:", score[0])
print("Test accuracy:", score[1])